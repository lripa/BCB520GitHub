library(dplyr)
library(sf)
library(readxl)
participants <- readxl::read_excel("BVBD Applicants Merged.xlsx")
world <- ne_countries(scale = "medium", returnclass = "sf")
world$centroid_lon <- st_coordinates(st_centroid(world$geometry))[, 1]
world$centroid_lat <- st_coordinates(st_centroid(world$geometry))[, 2]
participants_with_centroids <- participants %>%
left_join(world %>% select(name, centroid_lon, centroid_lat), by = c("Country" = "name"))
ggplot(data = participants_with_centroids) +
borders("world", colour = "gray", fill = "lightgray") + # Draw the base map
geom_point(aes(x = centroid_lon, y = centroid_lat, color = as.factor(Year), shape = as.factor(Year)), size = 2) + # Plot points with varying colors and shapes per Year
scale_color_viridis_d(name = "Year") + # Use a nice color scale for colors
scale_shape_manual(name = "Year", values = c(16, 17, 18, 19, 15, 8)) + # Manually set shapes, adjust values as needed based on the number of years
theme_minimal() +
labs(title = "Participants by Country and Year", x = "Longitude", y = "Latitude", color = "Year", shape = "Year") +
theme(legend.position = "bottom")
# Assuming 'participants' has a 'Country' column
# Count the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n())
# Join with world data to include geometry
world_with_applicants <- world %>%
left_join(applicants_summary, by = c("name" = "Country"))
# Plot with a gradient fill based on the number of applicants
ggplot(data = world_with_applicants) +
geom_sf(aes(fill = Applicants), color = "white") +
scale_fill_viridis_c(name = "Number of Applicants", na.value = "lightgrey") +
labs(title = "Global Distribution of Applicants") +
theme_minimal()
library(rnaturalearth)
library(ggplot2)
library(dplyr)
library(sf)
library(readxl)
participants <- readxl::read_excel("BVBD Applicants Merged.xlsx")
world <- ne_countries(scale = "medium", returnclass = "sf")
world$centroid_lon <- st_coordinates(st_centroid(world$geometry))[, 1]
world$centroid_lat <- st_coordinates(st_centroid(world$geometry))[, 2]
participants_with_centroids <- participants %>%
left_join(world %>% select(name, centroid_lon, centroid_lat), by = c("Country" = "name"))
# Join with world data to include geometry
world_with_applicants <- world %>%
left_join(applicants_summary, by = c("name" = "Country"))
# Plot with a gradient fill based on the number of applicants
ggplot(data = world_with_applicants) +
geom_sf(aes(fill = Applicants), color = "white") +
scale_fill_viridis_c(name = "Number of Applicants", na.value = "lightgrey",
limits = c(1, 150), oob = scales::squish) +  # Set the range from 1 to 150
labs(title = "Global Distribution of Applicants") +
theme_minimal()
# Join with world data to include geometry
world_with_applicants <- world %>%
left_join(applicants_summary, by = c("name" = "Country"))
# Plot with a gradient fill based on the number of applicants
ggplot(data = world_with_applicants) +
geom_sf(aes(fill = Applicants), color = "white") +
scale_fill_viridis_c(name = "Number of Applicants", na.value = "lightgrey") +
labs(title = "Global Distribution of Applicants") +
theme_minimal()
library(rnaturalearth)
library(ggplot2)
library(dplyr)
library(sf)
library(readxl)
participants <- readxl::read_excel("BVBD Applicants Merged.xlsx")
world <- ne_countries(scale = "medium", returnclass = "sf")
world$centroid_lon <- st_coordinates(st_centroid(world$geometry))[, 1]
world$centroid_lat <- st_coordinates(st_centroid(world$geometry))[, 2]
participants_with_centroids <- participants %>%
left_join(world %>% select(name, centroid_lon, centroid_lat), by = c("Country" = "name"))
ggplot(data = participants_with_centroids) +
borders("world", colour = "gray", fill = "lightgray") + # Draw the base map
geom_point(aes(x = centroid_lon, y = centroid_lat, color = as.factor(Year), shape = as.factor(Year)), size = 2) + # Plot points with varying colors and shapes per Year
scale_color_viridis_d(name = "Year") + # Use a nice color scale for colors
scale_shape_manual(name = "Year", values = c(16, 17, 18, 19, 15, 8)) + # Manually set shapes, adjust values as needed based on the number of years
theme_minimal() +
labs(title = "Participants by Country and Year", x = "Longitude", y = "Latitude", color = "Year", shape = "Year") +
theme(legend.position = "bottom")
# Assuming 'participants' has a 'Country' column
# Count the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n())
# Join with world data to include geometry
world_with_applicants <- world %>%
left_join(applicants_summary, by = c("name" = "Country"))
# Plot with a gradient fill based on the number of applicants
ggplot(data = world_with_applicants) +
geom_sf(aes(fill = Applicants), color = "white") +
scale_fill_viridis_c(name = "Number of Applicants", na.value = "lightgrey",
limits = c(1, 150), oob = scales::squish) +  # Set the range from 1 to 150
labs(title = "Global Distribution of Applicants") +
theme_minimal()
library(rnaturalearth)
library(ggplot2)
library(dplyr)
library(sf)
library(readxl)
participants <- readxl::read_excel("BVBD Applicants Merged.xlsx")
world <- ne_countries(scale = "medium", returnclass = "sf")
world$centroid_lon <- st_coordinates(st_centroid(world$geometry))[, 1]
world$centroid_lat <- st_coordinates(st_centroid(world$geometry))[, 2]
participants_with_centroids <- participants %>%
left_join(world %>% select(name, centroid_lon, centroid_lat), by = c("Country" = "name"))
ggplot(data = participants_with_centroids) +
borders("world", colour = "gray", fill = "lightgray") + # Draw the base map
geom_point(aes(x = centroid_lon, y = centroid_lat, color = as.factor(Year), shape = as.factor(Year)), size = 2) + # Plot points with varying colors and shapes per Year
scale_color_viridis_d(name = "Year") + # Use a nice color scale for colors
scale_shape_manual(name = "Year", values = c(16, 17, 18, 19, 15, 8)) + # Manually set shapes, adjust values as needed based on the number of years
theme_minimal() +
labs(title = "Participants by Country and Year", x = "Longitude", y = "Latitude", color = "Year", shape = "Year") +
theme(legend.position = "bottom")
# Assuming 'participants' has a 'Country' column
# Count the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n())
# Join with world data to include geometry
world_with_applicants <- world %>%
left_join(applicants_summary, by = c("name" = "Country"))
# Plot with a gradient fill based on the number of applicants
ggplot(data = world_with_applicants) +
geom_sf(aes(fill = Applicants), color = "white") +
scale_fill_viridis_c(name = "Number of Applicants", na.value = "lightgrey",
limits = c(1, 150), oob = scales::squish) +  # Set the range from 1 to 150
labs(title = "Global Distribution of Applicants") +
theme_minimal()
library(leaflet)
install.packages("leaflet")
library(leaflet)
library(viridis)
install.packages("leaflet")
install.packages("viridis")
install.packages("htmltools")
install.packages("stringr")
library(leaflet)
library(viridis)
library(htmltools)
library(stringr)
# Assuming 'spdf' is your spatial data frame with an 'Applicants' column
qpal <- colorQuantile(rev(viridis::viridis(5)), spdf$Applicants, n = 5)
install.packages("leaflet")
library(leaflet)
library(viridis)
library(htmltools)
library(stringr)
# Assuming 'spdf' is your spatial data frame with an 'Applicants' column
qpal <- colorQuantile(rev(viridis::viridis(5)), spdf$Applicants, n = 5)
library(readxl)
library(dplyr)
library(sf)
library(rnaturalearth)
library(leaflet)
library(viridis)
# Assuming your dataset is loaded into `participants`
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Count the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Get world countries' spatial data
world <- ne_countries(scale = "medium", returnclass = "sf")
# Merge applicants data with spatial data
world_with_applicants <- world %>%
left_join(applicants_summary, by = c("name" = "Country"))
# Define a color palette function based on the number of applicants
# This uses a continuous scale since we're dealing with counts
qpal <- colorNumeric(palette = "viridis", domain = world_with_applicants$Applicants, na.color = "lightgrey")
# Create the leaflet map
leaflet(world_with_applicants) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addPolygons(fillColor = ~qpal(Applicants),
color = "#2b2b2b",
fillOpacity = 0.7,
weight = 0.5,
popup = ~paste(name, "<br>", "Applicants: ", Applicants)) %>%
addLegend(pal = qpal, values = ~Applicants,
title = "Number of Applicants",
position = "bottomright") %>%
setView(lat = 0, lng = 0, zoom = 2)
library(readxl)
library(dplyr)
library(sf)
library(rnaturalearth)
library(leaflet)
library(viridis)
# Assuming your dataset is loaded into `participants`
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Count the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Get world countries' spatial data
world <- ne_countries(scale = "medium", returnclass = "sf")
# Merge applicants data with spatial data
world_with_applicants <- world %>%
left_join(applicants_summary, by = c("name" = "Country"))
# Define a color palette function based on the number of applicants
# This uses a continuous scale since we're dealing with counts
qpal <- colorNumeric(palette = "viridis", domain = world_with_applicants$Applicants, na.color = "lightgrey")
# Create the leaflet map
leaflet(world_with_applicants) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addPolygons(fillColor = ~qpal(Applicants),
color = "#2b2b2b",
fillOpacity = 0.7,
weight = 0.5,
popup = ~paste(name, "<br>", "Applicants: ", Applicants)) %>%
addLegend(pal = qpal, values = ~Applicants,
title = "Number of Applicants",
position = "bottomright") %>%
setView(lat = 0, lng = 0, zoom = 2)
library(plotly)
install.packages("plotly")
library(plotly)
library(dplyr)
library(countrycode)
install.packages("plotly")
install.packages("countrycode")
library(plotly)
library(dplyr)
library(countrycode)
install.packages("countrycode")
library(plotly)
library(dplyr)
library(countrycode)
# Assuming 'participants' is your dataset loaded from an Excel file
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Aggregating the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Adding ISO country codes to 'applicants_summary' for Plotly
applicants_summary$CODE <- countrycode(applicants_summary$Country, "country.name", "iso3c")
# Handling missing or incorrect country names
applicants_summary <- na.omit(applicants_summary)
#Set country boundaries as light grey
l <- list(color = toRGB("d1d1d1"), width = 0.5)
install.packages("countrycode")
library(plotly)
library(dplyr)
library(countrycode)
# Assuming 'participants' is your dataset loaded from an Excel file
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Aggregating the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Adding ISO country codes to 'applicants_summary' for Plotly
applicants_summary$CODE <- countrycode(applicants_summary$Country, "country.name", "iso3c")
# Handling missing or incorrect country names
applicants_summary <- na.omit(applicants_summary)
#Set country boundaries as light grey
l <- list(color = toRGB("d1d1d1"), width = 0.5)
install.packages("countrycode")
library(plotly)
library(dplyr)
library(countrycode)
# Assuming 'participants' is your dataset loaded from an Excel file
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Aggregating the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Adding ISO country codes to 'applicants_summary' for Plotly
applicants_summary$CODE <- countrycode(applicants_summary$Country, "country.name", "iso3c")
# Handling missing or incorrect country names
applicants_summary <- na.omit(applicants_summary)
#Set country boundaries as light grey
l <- list(color = toRGB("d1d1d1"), width = 0.5)
library(plotly)
library(dplyr)
library(countrycode)
# Assuming 'participants' is your dataset loaded from an Excel file
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Aggregating the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Adding ISO country codes to 'applicants_summary' for Plotly
applicants_summary$CODE <- countrycode(applicants_summary$Country, "country.name", "iso3c")
# Handling missing or incorrect country names
applicants_summary <- na.omit(applicants_summary)
#Set country boundaries as light grey
l <- list(color = toRGB("d1d1d1"), width = 0.5)
library(plotly)
library(dplyr)
library(countrycode)
# Assuming 'participants' is your dataset loaded from an Excel file
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Aggregating the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Adding ISO country codes to 'applicants_summary' for Plotly
applicants_summary$CODE <- countrycode(applicants_summary$Country, "country.name", "iso3c")
# Handling missing or incorrect country names
applicants_summary <- na.omit(applicants_summary)
#Set country boundaries as light grey
l <- list(color = "#d1d1d1", width = 0.5)
#Specify map projection and options
g <- list(
showframe = FALSE,
showcoastlines = FALSE,
projection = list(type = 'orthographic'),
resolution = '100',
showcountries = TRUE,
countrycolor = '#d1d1d1',
showocean = TRUE,
oceancolor = '#c9d2e0',
showlakes = TRUE,
lakecolor = '#99c0db',
showrivers = TRUE,
rivercolor = '#99c0db')
# Plotting
p <- plot_geo(applicants_summary) %>%
add_trace(opacity = 0.5, locations = ~CODE, colors = 'Reds', marker = list(size=~(10*Applicants)), type="scattergeo", mode="markers") %>%
add_trace(color = ~Applicants, colors = 'Reds', text = ~Country, locations = ~CODE, marker = list(line = l)) %>%
colorbar(title = 'Number of Applicants') %>%
layout(title = 'Number of Applicants Per Country', geo = g)
print(p)
# Load required libraries
library(plotly)
library(dplyr)
library(countrycode)
# Example dataset loading step (you would replace this with your actual data loading step)
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Aggregating the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Adding ISO country codes to 'applicants_summary' for Plotly
applicants_summary$CODE <- countrycode(applicants_summary$Country, "country.name", "iso3c")
# Handling missing or incorrect country names
applicants_summary <- na.omit(applicants_summary)
# Adjust marker size scaling for visibility
applicants_summary$Size <- sqrt(applicants_summary$Applicants) * 2  # Example scaling
#Set country boundaries as light grey
l <- list(color = "#d1d1d1", width = 0.5)
#Specify map projection and options
g <- list(
showframe = FALSE,
showcoastlines = FALSE,
projection = list(type = 'orthographic'),
resolution = '100',
showcountries = TRUE,
countrycolor = '#d1d1d1',
showocean = TRUE,
oceancolor = '#c9d2e0',
showlakes = TRUE,
lakecolor = '#99c0db',
showrivers = TRUE,
rivercolor = '#99c0db')
# Plotting with revised approach
p <- plot_geo(applicants_summary, locations = ~CODE, color = ~Applicants,
text = ~paste(Country, '<br>Applicants: ', Applicants),
colors = 'Reds', size = ~Size) %>%
add_markers() %>%
colorbar(title = 'Number of Applicants') %>%
layout(title = 'Number of Applicants Per Country', geo = g)
# Load required libraries
library(plotly)
library(dplyr)
library(countrycode)
# Example dataset loading step (you would replace this with your actual data loading step)
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Aggregating the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Adding ISO country codes to 'applicants_summary' for Plotly
applicants_summary$CODE <- countrycode(applicants_summary$Country, "country.name", "iso3c")
# Handling missing or incorrect country names
applicants_summary <- na.omit(applicants_summary)
# Adjust marker size scaling for visibility
applicants_summary$Size <- sqrt(applicants_summary$Applicants) * 2  # Example scaling
#Set country boundaries as light grey
l <- list(color = "#d1d1d1", width = 0.5)
#Specify map projection and options
g <- list(
showframe = FALSE,
showcoastlines = FALSE,
projection = list(type = 'natural earth'),
showcountries = TRUE,
countrycolor = toRGB("gray"),
showocean = TRUE,
oceancolor = toRGB("lightblue"),
showlakes = TRUE,
lakecolor = toRGB("lightblue"),
showrivers = TRUE,
rivercolor = toRGB("lightblue")
)
# Create the Plotly map
p <- plot_geo(applicants_summary, locations = ~CODE, text = ~paste(Country, '<br>Applicants: ', Applicants)) %>%
add_markers(size = ~Size, color = ~Applicants, colors = 'Reds') %>%
colorbar(title = 'Number of Applicants') %>%
layout(title = 'Number of Applicants Per Country', geo = g)
library(plotly)
library(dplyr)
library(countrycode)
# Assuming 'participants' is your dataset loaded from an Excel file
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Aggregating the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Adding ISO country codes to 'applicants_summary' for Plotly
applicants_summary$CODE <- countrycode(applicants_summary$Country, "country.name", "iso3c")
# Handling missing or incorrect country names
applicants_summary <- na.omit(applicants_summary)
#Set country boundaries as light grey
l <- list(color = "#d1d1d1", width = 0.5)
#Specify map projection and options
g <- list(
showframe = FALSE,
showcoastlines = FALSE,
projection = list(type = 'orthographic'),
resolution = '100',
showcountries = TRUE,
countrycolor = '#d1d1d1',
showocean = TRUE,
oceancolor = '#c9d2e0',
showlakes = TRUE,
lakecolor = '#99c0db',
showrivers = TRUE,
rivercolor = '#99c0db')
# Plotting
p <- plot_geo(applicants_summary) %>%
add_trace(opacity = 0.5, locations = ~CODE, colors = 'Reds', marker = list(size=~(10*Applicants)), type="scattergeo", mode="markers") %>%
add_trace(color = ~Applicants, colors = 'Reds', text = ~Country, locations = ~CODE, marker = list(line = l)) %>%
colorbar(title = 'Number of Applicants') %>%
layout(title = 'Number of Applicants Per Country', geo = g)
print(p)
library(plotly)
library(dplyr)
library(countrycode)
# Assuming 'participants' is your dataset loaded from an Excel file
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Aggregating the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Adding ISO country codes to 'applicants_summary' for Plotly
applicants_summary$CODE <- countrycode(applicants_summary$Country, "country.name", "iso3c")
# Handling missing or incorrect country names
applicants_summary <- na.omit(applicants_summary)
# Specify map projection and options
g <- list(
showframe = FALSE,
showcoastlines = FALSE,
projection = list(type = 'orthographic'),
resolution = '100',
showcountries = TRUE,
countrycolor = '#d1d1d1',
showocean = TRUE,
oceancolor = '#c9d2e0',
showlakes = TRUE,
lakecolor = '#99c0db',
showrivers = TRUE,
rivercolor = '#99c0db')
# Plotting with simplified trace
p <- plot_geo(applicants_summary, locations = ~CODE, text = ~paste(Country, '<br>Applicants: ', Applicants),
marker = list(size = ~sqrt(Applicants) * 10, color = ~Applicants, colorscale = 'Reds', line = list(color = "#d1d1d1", width = 0.5))) %>%
colorbar(title = 'Number of Applicants') %>%
layout(title = 'Number of Applicants Per Country', geo = g)
p
library(readxl)
library(dplyr)
library(sf)
library(rnaturalearth)
library(leaflet)
library(viridis)
# Assuming your dataset is loaded into `participants`
# participants <- readxl::read_excel("path/to/your/file.xlsx")
# Count the number of applicants per country
applicants_summary <- participants %>%
group_by(Country) %>%
summarise(Applicants = n()) %>%
ungroup()
# Get world countries' spatial data
world <- ne_countries(scale = "medium", returnclass = "sf")
# Merge applicants data with spatial data
world_with_applicants <- world %>%
left_join(applicants_summary, by = c("name" = "Country"))
# Define a color palette function based on the number of applicants
# This uses a continuous scale since we're dealing with counts
qpal <- colorNumeric(palette = "viridis", domain = world_with_applicants$Applicants, na.color = "lightgrey")
# Create the leaflet map
leaflet(world_with_applicants) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addPolygons(fillColor = ~qpal(Applicants),
color = "#2b2b2b",
fillOpacity = 0.7,
weight = 0.5,
popup = ~paste(name, "<br>", "Applicants: ", Applicants)) %>%
addLegend(pal = qpal, values = ~Applicants,
title = "Number of Applicants",
position = "bottomright") %>%
setView(lat = 0, lng = 0, zoom = 2)
